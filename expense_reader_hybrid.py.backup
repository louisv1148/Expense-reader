import os
import openai
import pytesseract
from PIL import Image
from dotenv import load_dotenv
import pandas as pd
from datetime import datetime
import json
import base64
import requests

# Load environment variables
load_dotenv()

class ExpenseReaderHybrid:
    def __init__(self, use_cloud_ai=False):
        self.use_cloud_ai = use_cloud_ai
        self.cloud_ai_url = "https://bz9xog04ff.execute-api.us-east-1.amazonaws.com/process"  # Your Lambda API
        
        if not use_cloud_ai:
            # Local processing setup
            self.client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
            tesseract_path = os.getenv('TESSERACT_PATH')
            if tesseract_path:
                pytesseract.pytesseract.tesseract_cmd = tesseract_path
    
    def extract_text_from_image(self, image_path):
        """Extract text from receipt image - local or cloud"""
        if self.use_cloud_ai:
            return self._extract_with_cloud_ai(image_path)
        else:
            return self._extract_local_ocr(image_path)
    
    def _extract_local_ocr(self, image_path):
        """Local OCR using Tesseract (original method)"""
        try:
            image = Image.open(image_path)
            if image.mode != 'RGB':
                image = image.convert('RGB')
            
            # Auto-rotate based on EXIF orientation
            try:
                exif = image._getexif()
                if exif is not None and 274 in exif:
                    orientation = exif[274]
                    if orientation == 3:
                        image = image.rotate(180, expand=True)
                    elif orientation == 6:
                        image = image.rotate(270, expand=True)
                    elif orientation == 8:
                        image = image.rotate(90, expand=True)
            except:
                pass
            
            # Extract text using Tesseract
            text = pytesseract.image_to_string(image)
            return text.strip()
        except Exception as e:
            print(f"OCR Error: {str(e)}")
            return ""
    
    def _extract_with_cloud_ai(self, image_path):
        """Cloud AI processing using Lambda"""
        try:
            # Convert image to base64
            with open(image_path, 'rb') as image_file:
                image_base64 = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call Lambda API
            response = requests.post(
                self.cloud_ai_url,
                json={'image_base64': image_base64},
                headers={'Content-Type': 'application/json'},
                timeout=60
            )
            
            if response.status_code == 200:
                result = response.json()
                return result.get('ocr_text', '')
            else:
                print(f"Cloud AI Error: {response.status_code}")
                return ""
                
        except Exception as e:
            print(f"Cloud AI Error: {str(e)}")
            return ""
    
    def extract_receipt_data(self, ocr_text):
        """Extract structured data from OCR text"""
        if self.use_cloud_ai:
            # Data already extracted in cloud call
            return self._extract_with_cloud_data(ocr_text)
        else:
            return self._extract_local_ai(ocr_text)
    
    def _extract_local_ai(self, ocr_text):
        """Local AI processing (original method)"""
        try:
            prompt = f"""Extract the following information from this receipt text:
- Restaurant name
- Date (format: YYYY-MM-DD)
- Total amount (just the number, no currency symbol)

Receipt text:
{ocr_text}

Return the information in this exact JSON format:
{{"restaurant_name": "name", "date": "YYYY-MM-DD", "total_amount": 0.00}}"""

            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=200,
                temperature=0
            )
            
            result = response.choices[0].message.content.strip()
            return json.loads(result)
            
        except Exception as e:
            print(f"AI Extraction Error: {str(e)}")
            return None
    
    def _extract_with_cloud_data(self, ocr_text):
        """Get extracted data from previous cloud call"""
        # In a real implementation, you'd cache this from the cloud call
        # For now, just return None to trigger local fallback
        return None